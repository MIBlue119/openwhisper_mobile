# Create a plan for a new feature or bug fix

## Introduction

**Note: The current year is 2026.** Use this when dating plans and searching for recent documentation.

Transform feature descriptions, bug reports, or improvement ideas into well-structured markdown files issues that follow project conventions and best practices. This command provides flexible detail levels to match your needs.

## Feature Description

<feature_description> #Ë´ã‰Ω†Âπ´ÊàëÁ¢∫Ë™çÊàëÁöÑÈÄôÂÄãË¶èÂäÉ /Users/weirenlan/Desktop/self_project/labs/openwhisper_mobile/docs/plans/2026-02-12-research-ios-keyboard-extension.md ÊòØÂê¶Ë∑ü /Users/weirenlan/Desktop/self_project/labs/openwhisper_mobile/docs/plans/2026-02-12-feat-ios-react-native-port-plan.md Â∞çÈΩä </feature_description>

**If the feature description above is empty, ask the user:** "What would you like to plan? Please describe the feature, bug fix, or improvement you have in mind."

Do not proceed until you have a clear feature description from the user.

### 0. Idea Refinement

**Check for brainstorm output first:**

Before asking questions, look for recent brainstorm documents in `docs/brainstorms/` that match this feature:

```bash
ls -la docs/brainstorms/*.md 2>/dev/null | head -10
```

**Relevance criteria:** A brainstorm is relevant if:
- The topic (from filename or YAML frontmatter) semantically matches the feature description
- Created within the last 14 days
- If multiple candidates match, use the most recent one

**If a relevant brainstorm exists:**
1. Read the brainstorm document
2. Announce: "Found brainstorm from [date]: [topic]. Using as context for planning."
3. Extract key decisions, chosen approach, and open questions
4. **Skip the idea refinement questions below** - the brainstorm already answered WHAT to build
5. Use brainstorm decisions as input to the research phase

**If multiple brainstorms could match:**
Use **AskUserQuestion tool** to ask which brainstorm to use, or whether to proceed without one.

**If no brainstorm found (or not relevant), run idea refinement:**

Refine the idea through collaborative dialogue using the **AskUserQuestion tool**:

- Ask questions one at a time to understand the idea fully
- Prefer multiple choice questions when natural options exist
- Focus on understanding: purpose, constraints and success criteria
- Continue until the idea is clear OR user says "proceed"

**Gather signals for research decision.** During refinement, note:

- **User's familiarity**: Do they know the codebase patterns? Are they pointing to examples?
- **User's intent**: Speed vs thoroughness? Exploration vs execution?
- **Topic risk**: Security, payments, external APIs warrant more caution
- **Uncertainty level**: Is the approach clear or open-ended?

**Skip option:** If the feature description is already detailed, offer:
"Your description is clear. Should I proceed with research, or would you like to refine it further?"

## Main Tasks

### 1. Local Research (Always Runs - Parallel)

<thinking>
First, I need to understand the project's conventions, existing patterns, and any documented learnings. This is fast and local - it informs whether external research is needed.
</thinking>

Run these agents **in parallel** to gather local context:

- Task repo-research-analyst(feature_description)
- Task learnings-researcher(feature_description)

**What to look for:**
- **Repo research:** existing patterns, CLAUDE.md guidance, technology familiarity, pattern consistency
- **Learnings:** documented solutions in `docs/solutions/` that might apply (gotchas, patterns, lessons learned)

These findings inform the next step.

### 1.5. Research Decision

Based on signals from Step 0 and findings from Step 1, decide on external research.

**High-risk topics ‚Üí always research.** Security, payments, external APIs, data privacy. The cost of missing something is too high. This takes precedence over speed signals.

**Strong local context ‚Üí skip external research.** Codebase has good patterns, CLAUDE.md has guidance, user knows what they want. External research adds little value.

**Uncertainty or unfamiliar territory ‚Üí research.** User is exploring, codebase has no examples, new technology. External perspective is valuable.

**Announce the decision and proceed.** Brief explanation, then continue. User can redirect if needed.

Examples:
- "Your codebase has solid patterns for this. Proceeding without external research."
- "This involves payment processing, so I'll research current best practices first."

### 1.5b. External Research (Conditional)

**Only run if Step 1.5 indicates external research is valuable.**

Run these agents in parallel:

- Task best-practices-researcher(feature_description)
- Task framework-docs-researcher(feature_description)

### 1.6. Consolidate Research

After all research steps complete, consolidate findings:

- Document relevant file paths from repo research (e.g., `app/services/example_service.rb:42`)
- **Include relevant institutional learnings** from `docs/solutions/` (key insights, gotchas to avoid)
- Note external documentation URLs and best practices (if external research was done)
- List related issues or PRs discovered
- Capture CLAUDE.md conventions

**Optional validation:** Briefly summarize findings and ask if anything looks off or missing before proceeding to planning.

### 2. Issue Planning & Structure

<thinking>
Think like a product manager - what would make this issue clear and actionable? Consider multiple perspectives
</thinking>

**Title & Categorization:**

- [ ] Draft clear, searchable issue title using conventional format (e.g., `feat: Add user authentication`, `fix: Cart total calculation`)
- [ ] Determine issue type: enhancement, bug, refactor
- [ ] Convert title to filename: add today's date prefix, strip prefix colon, kebab-case, add `-plan` suffix
  - Example: `feat: Add User Authentication` ‚Üí `2026-01-21-feat-add-user-authentication-plan.md`
  - Keep it descriptive (3-5 words after prefix) so plans are findable by context

**Stakeholder Analysis:**

- [ ] Identify who will be affected by this issue (end users, developers, operations)
- [ ] Consider implementation complexity and required expertise

**Content Planning:**

- [ ] Choose appropriate detail level based on issue complexity and audience
- [ ] List all necessary sections for the chosen template
- [ ] Gather supporting materials (error logs, screenshots, design mockups)
- [ ] Prepare code examples or reproduction steps if applicable, name the mock filenames in the lists

### 3. SpecFlow Analysis

After planning the issue structure, run SpecFlow Analyzer to validate and refine the feature specification:

- Task spec-flow-analyzer(feature_description, research_findings)

**SpecFlow Analyzer Output:**

- [ ] Review SpecFlow analysis results
- [ ] Incorporate any identified gaps or edge cases into the issue
- [ ] Update acceptance criteria based on SpecFlow findings

### 4. Choose Implementation Detail Level

Select how comprehensive you want the issue to be, simpler is mostly better.

#### üìÑ MINIMAL (Quick Issue)

**Best for:** Simple bugs, small improvements, clear features

**Includes:**

- Problem statement or feature description
- Basic acceptance criteria
- Essential context only

**Structure:**

````markdown
---
title: [Issue Title]
type: [feat|fix|refactor]
date: YYYY-MM-DD
---

# [Issue Title]

[Brief problem/feature description]

## Acceptance Criteria

- [ ] Core requirement 1
- [ ] Core requirement 2

## Context

[Any critical information]

## MVP

### test.rb

```ruby
class Test
  def initialize
    @name = "test"
  end
end
```

## References

- Related issue: #[issue_number]
- Documentation: [relevant_docs_url]
````

#### üìã MORE (Standard Issue)

**Best for:** Most features, complex bugs, team collaboration

**Includes everything from MINIMAL plus:**

- Detailed background and motivation
- Technical considerations
- Success metrics
- Dependencies and risks
- Basic implementation suggestions

**Structure:**

```markdown
---
title: [Issue Title]
type: [feat|fix|refactor]
date: YYYY-MM-DD
---

# [Issue Title]

## Overview

[Comprehensive description]

## Problem Statement / Motivation

[Why this matters]

## Proposed Solution

[High-level approach]

## Technical Considerations

- Architecture impacts
- Performance implications
- Security considerations

## Acceptance Criteria

- [ ] Detailed requirement 1
- [ ] Detailed requirement 2
- [ ] Testing requirements

## Success Metrics

[How we measure success]

## Dependencies & Risks

[What could block or complicate this]

## References & Research

- Similar implementations: [file_path:line_number]
- Best practices: [documentation_url]
- Related PRs: #[pr_number]
```

#### üìö A LOT (Comprehensive Issue)

**Best for:** Major features, architectural changes, complex integrations

**Includes everything from MORE plus:**

- Detailed implementation plan with phases
- Alternative approaches considered
- Extensive technical specifications
- Resource requirements and timeline
- Future considerations and extensibility
- Risk mitigation strategies
- Documentation requirements

**Structure:**

```markdown
---
title: [Issue Title]
type: [feat|fix|refactor]
date: YYYY-MM-DD
---

# [Issue Title]

## Overview

[Executive summary]

## Problem Statement

[Detailed problem analysis]

## Proposed Solution

[Comprehensive solution design]

## Technical Approach

### Architecture

[Detailed technical design]

### Implementation Phases

#### Phase 1: [Foundation]

- Tasks and deliverables
- Success criteria
- Estimated effort

#### Phase 2: [Core Implementation]

- Tasks and deliverables
- Success criteria
- Estimated effort

#### Phase 3: [Polish & Optimization]

- Tasks and deliverables
- Success criteria
- Estimated effort

## Alternative Approaches Considered

[Other solutions evaluated and why rejected]

## Acceptance Criteria

### Functional Requirements

- [ ] Detailed functional criteria

### Non-Functional Requirements

- [ ] Performance targets
- [ ] Security requirements
- [ ] Accessibility standards

### Quality Gates

- [ ] Test coverage requirements
- [ ] Documentation completeness
- [ ] Code review approval

## Success Metrics

[Detailed KPIs and measurement methods]

## Dependencies & Prerequisites

[Detailed dependency analysis]

## Risk Analysis & Mitigation

[Comprehensive risk assessment]

## Resource Requirements

[Team, time, infrastructure needs]

## Future Considerations

[Extensibility and long-term vision]

## Documentation Plan

[What docs need updating]

## References & Research

### Internal References

- Architecture decisions: [file_path:line_number]
- Similar features: [file_path:line_number]
- Configuration: [file_path:line_number]

### External References

- Framework documentation: [url]
- Best practices guide: [url]
- Industry standards: [url]

### Related Work

- Previous PRs: #[pr_numbers]
- Related issues: #[issue_numbers]
- Design documents: [links]
```

### 5. Issue Creation & Formatting

<thinking>
Apply best practices for clarity and actionability, making the issue easy to scan and understand
</thinking>

**Content Formatting:**

- [ ] Use clear, descriptive headings with proper hierarchy (##, ###)
- [ ] Include code examples in triple backticks with language syntax highlighting
- [ ] Add screenshots/mockups if UI-related (drag & drop or use image hosting)
- [ ] Use task lists (- [ ]) for trackable items that can be checked off
- [ ] Add collapsible sections for lengthy logs or optional details using `<details>` tags
- [ ] Apply appropriate emoji for visual scanning (üêõ bug, ‚ú® feature, üìö docs, ‚ôªÔ∏è refactor)

**Cross-Referencing:**

- [ ] Link to related issues/PRs using #number format
- [ ] Reference specific commits with SHA hashes when relevant
- [ ] Link to code using GitHub's permalink feature (press 'y' for permanent link)
- [ ] Mention relevant team members with @username if needed
- [ ] Add links to external resources with descriptive text

**Code & Examples:**

````markdown
# Good example with syntax highlighting and line references


```ruby
# app/services/user_service.rb:42
def process_user(user)

# Implementation here

end
```

# Collapsible error logs

<details>
<summary>Full error stacktrace</summary>

`Error details here...`

</details>
````

**AI-Era Considerations:**

- [ ] Account for accelerated development with AI pair programming
- [ ] Include prompts or instructions that worked well during research
- [ ] Note which AI tools were used for initial exploration (Claude, Copilot, etc.)
- [ ] Emphasize comprehensive testing given rapid implementation
- [ ] Document any AI-generated code that needs human review

### 6. Final Review & Submission

**Pre-submission Checklist:**

- [ ] Title is searchable and descriptive
- [ ] Labels accurately categorize the issue
- [ ] All template sections are complete
- [ ] Links and references are working
- [ ] Acceptance criteria are measurable
- [ ] Add names of files in pseudo code examples and todo lists
- [ ] Add an ERD mermaid diagram if applicable for new model changes

## Output Format

**Filename:** Use the date and kebab-case filename from Step 2 Title & Categorization.

```
docs/plans/YYYY-MM-DD-<type>-<descriptive-name>-plan.md
```

Examples:
- ‚úÖ `docs/plans/2026-01-15-feat-user-authentication-flow-plan.md`
- ‚úÖ `docs/plans/2026-02-03-fix-checkout-race-condition-plan.md`
- ‚úÖ `docs/plans/2026-03-10-refactor-api-client-extraction-plan.md`
- ‚ùå `docs/plans/2026-01-15-feat-thing-plan.md` (not descriptive - what "thing"?)
- ‚ùå `docs/plans/2026-01-15-feat-new-feature-plan.md` (too vague - what feature?)
- ‚ùå `docs/plans/2026-01-15-feat: user auth-plan.md` (invalid characters - colon and space)
- ‚ùå `docs/plans/feat-user-auth-plan.md` (missing date prefix)

## Post-Generation Options

After writing the plan file, use the **AskUserQuestion tool** to present these options:

**Question:** "Plan ready at `docs/plans/YYYY-MM-DD-<type>-<name>-plan.md`. What would you like to do next?"

**Options:**
1. **Open plan in editor** - Open the plan file for review
2. **Run `/deepen-plan`** - Enhance each section with parallel research agents (best practices, performance, UI)
3. **Run `/plan_review`** - Get feedback from reviewers (DHH, Kieran, Simplicity)
4. **Start `/workflows:work`** - Begin implementing this plan locally
5. **Start `/workflows:work` on remote** - Begin implementing in Claude Code on the web (use `&` to run in background)
6. **Create Issue** - Create issue in project tracker (GitHub/Linear)
7. **Simplify** - Reduce detail level

Based on selection:
- **Open plan in editor** ‚Üí Run `open docs/plans/<plan_filename>.md` to open the file in the user's default editor
- **`/deepen-plan`** ‚Üí Call the /deepen-plan command with the plan file path to enhance with research
- **`/plan_review`** ‚Üí Call the /plan_review command with the plan file path
- **`/workflows:work`** ‚Üí Call the /workflows:work command with the plan file path
- **`/workflows:work` on remote** ‚Üí Run `/workflows:work docs/plans/<plan_filename>.md &` to start work in background for Claude Code web
- **Create Issue** ‚Üí See "Issue Creation" section below
- **Simplify** ‚Üí Ask "What should I simplify?" then regenerate simpler version
- **Other** (automatically provided) ‚Üí Accept free text for rework or specific changes

**Note:** If running `/workflows:plan` with ultrathink enabled, automatically run `/deepen-plan` after plan creation for maximum depth and grounding.

Loop back to options after Simplify or Other changes until user selects `/workflows:work` or `/plan_review`.

## Issue Creation

When user selects "Create Issue", detect their project tracker from CLAUDE.md:

1. **Check for tracker preference** in user's CLAUDE.md (global or project):
   - Look for `project_tracker: github` or `project_tracker: linear`
   - Or look for mentions of "GitHub Issues" or "Linear" in their workflow section

2. **If GitHub:**

   Use the title and type from Step 2 (already in context - no need to re-read the file):

   ```bash
   gh issue create --title "<type>: <title>" --body-file <plan_path>
   ```

3. **If Linear:**

   ```bash
   linear issue create --title "<title>" --description "$(cat <plan_path>)"
   ```

4. **If no tracker configured:**
   Ask user: "Which project tracker do you use? (GitHub/Linear/Other)"
   - Suggest adding `project_tracker: github` or `project_tracker: linear` to their CLAUDE.md

5. **After creation:**
   - Display the issue URL
   - Ask if they want to proceed to `/workflows:work` or `/plan_review`

NEVER CODE! Just research and write the plan.

---

# Create a plan for a new feature or bug fix

## Introduction

**Note: The current year is 2026.** Use this when dating plans and searching for recent documentation.

Transform feature descriptions, bug reports, or improvement ideas into well-structured markdown files issues that follow project conventions and best practices. This command provides flexible detail levels to match your needs.

## Feature Description

<feature_description> #/Users/weirenlan/Desktop/self_project/labs/openwhisper_mobile/docs/plans/2026-02-12-research-ios-keyboard-extension.md </feature_description>

**If the feature description above is empty, ask the user:** "What would you like to plan? Please describe the feature, bug fix, or improvement you have in mind."

Do not proceed until you have a clear feature description from the user.

### 0. Idea Refinement

**Check for brainstorm output first:**

Before asking questions, look for recent brainstorm documents in `docs/brainstorms/` that match this feature:

```bash
ls -la docs/brainstorms/*.md 2>/dev/null | head -10
```

**Relevance criteria:** A brainstorm is relevant if:
- The topic (from filename or YAML frontmatter) semantically matches the feature description
- Created within the last 14 days
- If multiple candidates match, use the most recent one

**If a relevant brainstorm exists:**
1. Read the brainstorm document
2. Announce: "Found brainstorm from [date]: [topic]. Using as context for planning."
3. Extract key decisions, chosen approach, and open questions
4. **Skip the idea refinement questions below** - the brainstorm already answered WHAT to build
5. Use brainstorm decisions as input to the research phase

**If multiple brainstorms could match:**
Use **AskUserQuestion tool** to ask which brainstorm to use, or whether to proceed without one.

**If no brainstorm found (or not relevant), run idea refinement:**

Refine the idea through collaborative dialogue using the **AskUserQuestion tool**:

- Ask questions one at a time to understand the idea fully
- Prefer multiple choice questions when natural options exist
- Focus on understanding: purpose, constraints and success criteria
- Continue until the idea is clear OR user says "proceed"

**Gather signals for research decision.** During refinement, note:

- **User's familiarity**: Do they know the codebase patterns? Are they pointing to examples?
- **User's intent**: Speed vs thoroughness? Exploration vs execution?
- **Topic risk**: Security, payments, external APIs warrant more caution
- **Uncertainty level**: Is the approach clear or open-ended?

**Skip option:** If the feature description is already detailed, offer:
"Your description is clear. Should I proceed with research, or would you like to refine it further?"

## Main Tasks

### 1. Local Research (Always Runs - Parallel)

<thinking>
First, I need to understand the project's conventions, existing patterns, and any documented learnings. This is fast and local - it informs whether external research is needed.
</thinking>

Run these agents **in parallel** to gather local context:

- Task repo-research-analyst(feature_description)
- Task learnings-researcher(feature_description)

**What to look for:**
- **Repo research:** existing patterns, CLAUDE.md guidance, technology familiarity, pattern consistency
- **Learnings:** documented solutions in `docs/solutions/` that might apply (gotchas, patterns, lessons learned)

These findings inform the next step.

### 1.5. Research Decision

Based on signals from Step 0 and findings from Step 1, decide on external research.

**High-risk topics ‚Üí always research.** Security, payments, external APIs, data privacy. The cost of missing something is too high. This takes precedence over speed signals.

**Strong local context ‚Üí skip external research.** Codebase has good patterns, CLAUDE.md has guidance, user knows what they want. External research adds little value.

**Uncertainty or unfamiliar territory ‚Üí research.** User is exploring, codebase has no examples, new technology. External perspective is valuable.

**Announce the decision and proceed.** Brief explanation, then continue. User can redirect if needed.

Examples:
- "Your codebase has solid patterns for this. Proceeding without external research."
- "This involves payment processing, so I'll research current best practices first."

### 1.5b. External Research (Conditional)

**Only run if Step 1.5 indicates external research is valuable.**

Run these agents in parallel:

- Task best-practices-researcher(feature_description)
- Task framework-docs-researcher(feature_description)

### 1.6. Consolidate Research

After all research steps complete, consolidate findings:

- Document relevant file paths from repo research (e.g., `app/services/example_service.rb:42`)
- **Include relevant institutional learnings** from `docs/solutions/` (key insights, gotchas to avoid)
- Note external documentation URLs and best practices (if external research was done)
- List related issues or PRs discovered
- Capture CLAUDE.md conventions

**Optional validation:** Briefly summarize findings and ask if anything looks off or missing before proceeding to planning.

### 2. Issue Planning & Structure

<thinking>
Think like a product manager - what would make this issue clear and actionable? Consider multiple perspectives
</thinking>

**Title & Categorization:**

- [ ] Draft clear, searchable issue title using conventional format (e.g., `feat: Add user authentication`, `fix: Cart total calculation`)
- [ ] Determine issue type: enhancement, bug, refactor
- [ ] Convert title to filename: add today's date prefix, strip prefix colon, kebab-case, add `-plan` suffix
  - Example: `feat: Add User Authentication` ‚Üí `2026-01-21-feat-add-user-authentication-plan.md`
  - Keep it descriptive (3-5 words after prefix) so plans are findable by context

**Stakeholder Analysis:**

- [ ] Identify who will be affected by this issue (end users, developers, operations)
- [ ] Consider implementation complexity and required expertise

**Content Planning:**

- [ ] Choose appropriate detail level based on issue complexity and audience
- [ ] List all necessary sections for the chosen template
- [ ] Gather supporting materials (error logs, screenshots, design mockups)
- [ ] Prepare code examples or reproduction steps if applicable, name the mock filenames in the lists

### 3. SpecFlow Analysis

After planning the issue structure, run SpecFlow Analyzer to validate and refine the feature specification:

- Task spec-flow-analyzer(feature_description, research_findings)

**SpecFlow Analyzer Output:**

- [ ] Review SpecFlow analysis results
- [ ] Incorporate any identified gaps or edge cases into the issue
- [ ] Update acceptance criteria based on SpecFlow findings

### 4. Choose Implementation Detail Level

Select how comprehensive you want the issue to be, simpler is mostly better.

#### üìÑ MINIMAL (Quick Issue)

**Best for:** Simple bugs, small improvements, clear features

**Includes:**

- Problem statement or feature description
- Basic acceptance criteria
- Essential context only

**Structure:**

````markdown
---
title: [Issue Title]
type: [feat|fix|refactor]
date: YYYY-MM-DD
---

# [Issue Title]

[Brief problem/feature description]

## Acceptance Criteria

- [ ] Core requirement 1
- [ ] Core requirement 2

## Context

[Any critical information]

## MVP

### test.rb

```ruby
class Test
  def initialize
    @name = "test"
  end
end
```

## References

- Related issue: #[issue_number]
- Documentation: [relevant_docs_url]
````

#### üìã MORE (Standard Issue)

**Best for:** Most features, complex bugs, team collaboration

**Includes everything from MINIMAL plus:**

- Detailed background and motivation
- Technical considerations
- Success metrics
- Dependencies and risks
- Basic implementation suggestions

**Structure:**

```markdown
---
title: [Issue Title]
type: [feat|fix|refactor]
date: YYYY-MM-DD
---

# [Issue Title]

## Overview

[Comprehensive description]

## Problem Statement / Motivation

[Why this matters]

## Proposed Solution

[High-level approach]

## Technical Considerations

- Architecture impacts
- Performance implications
- Security considerations

## Acceptance Criteria

- [ ] Detailed requirement 1
- [ ] Detailed requirement 2
- [ ] Testing requirements

## Success Metrics

[How we measure success]

## Dependencies & Risks

[What could block or complicate this]

## References & Research

- Similar implementations: [file_path:line_number]
- Best practices: [documentation_url]
- Related PRs: #[pr_number]
```

#### üìö A LOT (Comprehensive Issue)

**Best for:** Major features, architectural changes, complex integrations

**Includes everything from MORE plus:**

- Detailed implementation plan with phases
- Alternative approaches considered
- Extensive technical specifications
- Resource requirements and timeline
- Future considerations and extensibility
- Risk mitigation strategies
- Documentation requirements

**Structure:**

```markdown
---
title: [Issue Title]
type: [feat|fix|refactor]
date: YYYY-MM-DD
---

# [Issue Title]

## Overview

[Executive summary]

## Problem Statement

[Detailed problem analysis]

## Proposed Solution

[Comprehensive solution design]

## Technical Approach

### Architecture

[Detailed technical design]

### Implementation Phases

#### Phase 1: [Foundation]

- Tasks and deliverables
- Success criteria
- Estimated effort

#### Phase 2: [Core Implementation]

- Tasks and deliverables
- Success criteria
- Estimated effort

#### Phase 3: [Polish & Optimization]

- Tasks and deliverables
- Success criteria
- Estimated effort

## Alternative Approaches Considered

[Other solutions evaluated and why rejected]

## Acceptance Criteria

### Functional Requirements

- [ ] Detailed functional criteria

### Non-Functional Requirements

- [ ] Performance targets
- [ ] Security requirements
- [ ] Accessibility standards

### Quality Gates

- [ ] Test coverage requirements
- [ ] Documentation completeness
- [ ] Code review approval

## Success Metrics

[Detailed KPIs and measurement methods]

## Dependencies & Prerequisites

[Detailed dependency analysis]

## Risk Analysis & Mitigation

[Comprehensive risk assessment]

## Resource Requirements

[Team, time, infrastructure needs]

## Future Considerations

[Extensibility and long-term vision]

## Documentation Plan

[What docs need updating]

## References & Research

### Internal References

- Architecture decisions: [file_path:line_number]
- Similar features: [file_path:line_number]
- Configuration: [file_path:line_number]

### External References

- Framework documentation: [url]
- Best practices guide: [url]
- Industry standards: [url]

### Related Work

- Previous PRs: #[pr_numbers]
- Related issues: #[issue_numbers]
- Design documents: [links]
```

### 5. Issue Creation & Formatting

<thinking>
Apply best practices for clarity and actionability, making the issue easy to scan and understand
</thinking>

**Content Formatting:**

- [ ] Use clear, descriptive headings with proper hierarchy (##, ###)
- [ ] Include code examples in triple backticks with language syntax highlighting
- [ ] Add screenshots/mockups if UI-related (drag & drop or use image hosting)
- [ ] Use task lists (- [ ]) for trackable items that can be checked off
- [ ] Add collapsible sections for lengthy logs or optional details using `<details>` tags
- [ ] Apply appropriate emoji for visual scanning (üêõ bug, ‚ú® feature, üìö docs, ‚ôªÔ∏è refactor)

**Cross-Referencing:**

- [ ] Link to related issues/PRs using #number format
- [ ] Reference specific commits with SHA hashes when relevant
- [ ] Link to code using GitHub's permalink feature (press 'y' for permanent link)
- [ ] Mention relevant team members with @username if needed
- [ ] Add links to external resources with descriptive text

**Code & Examples:**

````markdown
# Good example with syntax highlighting and line references


```ruby
# app/services/user_service.rb:42
def process_user(user)

# Implementation here

end
```

# Collapsible error logs

<details>
<summary>Full error stacktrace</summary>

`Error details here...`

</details>
````

**AI-Era Considerations:**

- [ ] Account for accelerated development with AI pair programming
- [ ] Include prompts or instructions that worked well during research
- [ ] Note which AI tools were used for initial exploration (Claude, Copilot, etc.)
- [ ] Emphasize comprehensive testing given rapid implementation
- [ ] Document any AI-generated code that needs human review

### 6. Final Review & Submission

**Pre-submission Checklist:**

- [ ] Title is searchable and descriptive
- [ ] Labels accurately categorize the issue
- [ ] All template sections are complete
- [ ] Links and references are working
- [ ] Acceptance criteria are measurable
- [ ] Add names of files in pseudo code examples and todo lists
- [ ] Add an ERD mermaid diagram if applicable for new model changes

## Output Format

**Filename:** Use the date and kebab-case filename from Step 2 Title & Categorization.

```
docs/plans/YYYY-MM-DD-<type>-<descriptive-name>-plan.md
```

Examples:
- ‚úÖ `docs/plans/2026-01-15-feat-user-authentication-flow-plan.md`
- ‚úÖ `docs/plans/2026-02-03-fix-checkout-race-condition-plan.md`
- ‚úÖ `docs/plans/2026-03-10-refactor-api-client-extraction-plan.md`
- ‚ùå `docs/plans/2026-01-15-feat-thing-plan.md` (not descriptive - what "thing"?)
- ‚ùå `docs/plans/2026-01-15-feat-new-feature-plan.md` (too vague - what feature?)
- ‚ùå `docs/plans/2026-01-15-feat: user auth-plan.md` (invalid characters - colon and space)
- ‚ùå `docs/plans/feat-user-auth-plan.md` (missing date prefix)

## Post-Generation Options

After writing the plan file, use the **AskUserQuestion tool** to present these options:

**Question:** "Plan ready at `docs/plans/YYYY-MM-DD-<type>-<name>-plan.md`. What would you like to do next?"

**Options:**
1. **Open plan in editor** - Open the plan file for review
2. **Run `/deepen-plan`** - Enhance each section with parallel research agents (best practices, performance, UI)
3. **Run `/plan_review`** - Get feedback from reviewers (DHH, Kieran, Simplicity)
4. **Start `/workflows:work`** - Begin implementing this plan locally
5. **Start `/workflows:work` on remote** - Begin implementing in Claude Code on the web (use `&` to run in background)
6. **Create Issue** - Create issue in project tracker (GitHub/Linear)
7. **Simplify** - Reduce detail level

Based on selection:
- **Open plan in editor** ‚Üí Run `open docs/plans/<plan_filename>.md` to open the file in the user's default editor
- **`/deepen-plan`** ‚Üí Call the /deepen-plan command with the plan file path to enhance with research
- **`/plan_review`** ‚Üí Call the /plan_review command with the plan file path
- **`/workflows:work`** ‚Üí Call the /workflows:work command with the plan file path
- **`/workflows:work` on remote** ‚Üí Run `/workflows:work docs/plans/<plan_filename>.md &` to start work in background for Claude Code web
- **Create Issue** ‚Üí See "Issue Creation" section below
- **Simplify** ‚Üí Ask "What should I simplify?" then regenerate simpler version
- **Other** (automatically provided) ‚Üí Accept free text for rework or specific changes

**Note:** If running `/workflows:plan` with ultrathink enabled, automatically run `/deepen-plan` after plan creation for maximum depth and grounding.

Loop back to options after Simplify or Other changes until user selects `/workflows:work` or `/plan_review`.

## Issue Creation

When user selects "Create Issue", detect their project tracker from CLAUDE.md:

1. **Check for tracker preference** in user's CLAUDE.md (global or project):
   - Look for `project_tracker: github` or `project_tracker: linear`
   - Or look for mentions of "GitHub Issues" or "Linear" in their workflow section

2. **If GitHub:**

   Use the title and type from Step 2 (already in context - no need to re-read the file):

   ```bash
   gh issue create --title "<type>: <title>" --body-file <plan_path>
   ```

3. **If Linear:**

   ```bash
   linear issue create --title "<title>" --description "$(cat <plan_path>)"
   ```

4. **If no tracker configured:**
   Ask user: "Which project tracker do you use? (GitHub/Linear/Other)"
   - Suggest adding `project_tracker: github` or `project_tracker: linear` to their CLAUDE.md

5. **After creation:**
   - Display the issue URL
   - Ask if they want to proceed to `/workflows:work` or `/plan_review`

NEVER CODE! Just research and write the plan.

---

[Request interrupted by user for tool use]

---

# Work Plan Execution Command

Execute a work plan efficiently while maintaining quality and finishing features.

## Introduction

This command takes a work document (plan, specification, or todo file) and executes it systematically. The focus is on **shipping complete features** by understanding requirements quickly, following existing patterns, and maintaining quality throughout.

## Input Document

<input_document> #/Users/weirenlan/Desktop/self_project/labs/openwhisper_mobile/docs/plans/2026-02-12-research-ios-keyboard-extension.md </input_document>

## Execution Workflow

### Phase 1: Quick Start

1. **Read Plan and Clarify**

   - Read the work document completely
   - Review any references or links provided in the plan
   - If anything is unclear or ambiguous, ask clarifying questions now
   - Get user approval to proceed
   - **Do not skip this** - better to ask questions now than build the wrong thing

2. **Setup Environment**

   First, check the current branch:

   ```bash
   current_branch=$(git branch --show-current)
   default_branch=$(git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/remotes/origin/@@')

   # Fallback if remote HEAD isn't set
   if [ -z "$default_branch" ]; then
     default_branch=$(git rev-parse --verify origin/main >/dev/null 2>&1 && echo "main" || echo "master")
   fi
   ```

   **If already on a feature branch** (not the default branch):
   - Ask: "Continue working on `[current_branch]`, or create a new branch?"
   - If continuing, proceed to step 3
   - If creating new, follow Option A or B below

   **If on the default branch**, choose how to proceed:

   **Option A: Create a new branch**
   ```bash
   git pull origin [default_branch]
   git checkout -b feature-branch-name
   ```
   Use a meaningful name based on the work (e.g., `feat/user-authentication`, `fix/email-validation`).

   **Option B: Use a worktree (recommended for parallel development)**
   ```bash
   skill: git-worktree
   # The skill will create a new branch from the default branch in an isolated worktree
   ```

   **Option C: Continue on the default branch**
   - Requires explicit user confirmation
   - Only proceed after user explicitly says "yes, commit to [default_branch]"
   - Never commit directly to the default branch without explicit permission

   **Recommendation**: Use worktree if:
   - You want to work on multiple features simultaneously
   - You want to keep the default branch clean while experimenting
   - You plan to switch between branches frequently

3. **Create Todo List**
   - Use TodoWrite to break plan into actionable tasks
   - Include dependencies between tasks
   - Prioritize based on what needs to be done first
   - Include testing and quality check tasks
   - Keep tasks specific and completable

### Phase 2: Execute

1. **Task Execution Loop**

   For each task in priority order:

   ```
   while (tasks remain):
     - Mark task as in_progress in TodoWrite
     - Read any referenced files from the plan
     - Look for similar patterns in codebase
     - Implement following existing conventions
     - Write tests for new functionality
     - Run tests after changes
     - Mark task as completed in TodoWrite
     - Mark off the corresponding checkbox in the plan file ([ ] ‚Üí [x])
     - Evaluate for incremental commit (see below)
   ```

   **IMPORTANT**: Always update the original plan document by checking off completed items. Use the Edit tool to change `- [ ]` to `- [x]` for each task you finish. This keeps the plan as a living document showing progress and ensures no checkboxes are left unchecked.

2. **Incremental Commits**

   After completing each task, evaluate whether to create an incremental commit:

   | Commit when... | Don't commit when... |
   |----------------|---------------------|
   | Logical unit complete (model, service, component) | Small part of a larger unit |
   | Tests pass + meaningful progress | Tests failing |
   | About to switch contexts (backend ‚Üí frontend) | Purely scaffolding with no behavior |
   | About to attempt risky/uncertain changes | Would need a "WIP" commit message |

   **Heuristic:** "Can I write a commit message that describes a complete, valuable change? If yes, commit. If the message would be 'WIP' or 'partial X', wait."

   **Commit workflow:**
   ```bash
   # 1. Verify tests pass (use project's test command)
   # Examples: bin/rails test, npm test, pytest, go test, etc.

   # 2. Stage only files related to this logical unit (not `git add .`)
   git add <files related to this logical unit>

   # 3. Commit with conventional message
   git commit -m "feat(scope): description of this unit"
   ```

   **Handling merge conflicts:** If conflicts arise during rebasing or merging, resolve them immediately. Incremental commits make conflict resolution easier since each commit is small and focused.

   **Note:** Incremental commits use clean conventional messages without attribution footers. The final Phase 4 commit/PR includes the full attribution.

3. **Follow Existing Patterns**

   - The plan should reference similar code - read those files first
   - Match naming conventions exactly
   - Reuse existing components where possible
   - Follow project coding standards (see CLAUDE.md)
   - When in doubt, grep for similar implementations

4. **Test Continuously**

   - Run relevant tests after each significant change
   - Don't wait until the end to test
   - Fix failures immediately
   - Add new tests for new functionality

5. **Figma Design Sync** (if applicable)

   For UI work with Figma designs:

   - Implement components following design specs
   - Use figma-design-sync agent iteratively to compare
   - Fix visual differences identified
   - Repeat until implementation matches design

6. **Track Progress**
   - Keep TodoWrite updated as you complete tasks
   - Note any blockers or unexpected discoveries
   - Create new tasks if scope expands
   - Keep user informed of major milestones

### Phase 3: Quality Check

1. **Run Core Quality Checks**

   Always run before submitting:

   ```bash
   # Run full test suite (use project's test command)
   # Examples: bin/rails test, npm test, pytest, go test, etc.

   # Run linting (per CLAUDE.md)
   # Use linting-agent before pushing to origin
   ```

2. **Consider Reviewer Agents** (Optional)

   Use for complex, risky, or large changes:

   - **code-simplicity-reviewer**: Check for unnecessary complexity
   - **kieran-rails-reviewer**: Verify Rails conventions (Rails projects)
   - **performance-oracle**: Check for performance issues
   - **security-sentinel**: Scan for security vulnerabilities
   - **cora-test-reviewer**: Review test quality (Rails projects with comprehensive test coverage)

   Run reviewers in parallel with Task tool:

   ```
   Task(code-simplicity-reviewer): "Review changes for simplicity"
   Task(kieran-rails-reviewer): "Check Rails conventions"
   ```

   Present findings to user and address critical issues.

3. **Final Validation**
   - All TodoWrite tasks marked completed
   - All tests pass
   - Linting passes
   - Code follows existing patterns
   - Figma designs match (if applicable)
   - No console errors or warnings

### Phase 4: Ship It

1. **Create Commit**

   ```bash
   git add .
   git status  # Review what's being committed
   git diff --staged  # Check the changes

   # Commit with conventional format
   git commit -m "$(cat <<'EOF'
   feat(scope): description of what and why

   Brief explanation if needed.

   ü§ñ Generated with [Claude Code](https://claude.com/claude-code)

   Co-Authored-By: Claude <noreply@anthropic.com>
   EOF
   )"
   ```

2. **Capture and Upload Screenshots for UI Changes** (REQUIRED for any UI work)

   For **any** design changes, new views, or UI modifications, you MUST capture and upload screenshots:

   **Step 1: Start dev server** (if not running)
   ```bash
   bin/dev  # Run in background
   ```

   **Step 2: Capture screenshots with agent-browser CLI**
   ```bash
   agent-browser open http://localhost:3000/[route]
   agent-browser snapshot -i
   agent-browser screenshot output.png
   ```
   See the `agent-browser` skill for detailed usage.

   **Step 3: Upload using imgup skill**
   ```bash
   skill: imgup
   # Then upload each screenshot:
   imgup -h pixhost screenshot.png  # pixhost works without API key
   # Alternative hosts: catbox, imagebin, beeimg
   ```

   **What to capture:**
   - **New screens**: Screenshot of the new UI
   - **Modified screens**: Before AND after screenshots
   - **Design implementation**: Screenshot showing Figma design match

   **IMPORTANT**: Always include uploaded image URLs in PR description. This provides visual context for reviewers and documents the change.

3. **Create Pull Request**

   ```bash
   git push -u origin feature-branch-name

   gh pr create --title "Feature: [Description]" --body "$(cat <<'EOF'
   ## Summary
   - What was built
   - Why it was needed
   - Key decisions made

   ## Testing
   - Tests added/modified
   - Manual testing performed

   ## Before / After Screenshots
   | Before | After |
   |--------|-------|
   | ![before](URL) | ![after](URL) |

   ## Figma Design
   [Link if applicable]

   ---

   [![Compound Engineered](https://img.shields.io/badge/Compound-Engineered-6366f1)](https://github.com/EveryInc/compound-engineering-plugin) ü§ñ Generated with [Claude Code](https://claude.com/claude-code)
   EOF
   )"
   ```

4. **Notify User**
   - Summarize what was completed
   - Link to PR
   - Note any follow-up work needed
   - Suggest next steps if applicable

---

## Key Principles

### Start Fast, Execute Faster

- Get clarification once at the start, then execute
- Don't wait for perfect understanding - ask questions and move
- The goal is to **finish the feature**, not create perfect process

### The Plan is Your Guide

- Work documents should reference similar code and patterns
- Load those references and follow them
- Don't reinvent - match what exists

### Test As You Go

- Run tests after each change, not at the end
- Fix failures immediately
- Continuous testing prevents big surprises

### Quality is Built In

- Follow existing patterns
- Write tests for new code
- Run linting before pushing
- Use reviewer agents for complex/risky changes only

### Ship Complete Features

- Mark all tasks completed before moving on
- Don't leave features 80% done
- A finished feature that ships beats a perfect feature that doesn't

## Quality Checklist

Before creating PR, verify:

- [ ] All clarifying questions asked and answered
- [ ] All TodoWrite tasks marked completed
- [ ] Tests pass (run project's test command)
- [ ] Linting passes (use linting-agent)
- [ ] Code follows existing patterns
- [ ] Figma designs match implementation (if applicable)
- [ ] Before/after screenshots captured and uploaded (for UI changes)
- [ ] Commit messages follow conventional format
- [ ] PR description includes summary, testing notes, and screenshots
- [ ] PR description includes Compound Engineered badge

## When to Use Reviewer Agents

**Don't use by default.** Use reviewer agents only when:

- Large refactor affecting many files (10+)
- Security-sensitive changes (authentication, permissions, data access)
- Performance-critical code paths
- Complex algorithms or business logic
- User explicitly requests thorough review

For most features: tests + linting + following patterns is sufficient.

## Common Pitfalls to Avoid

- **Analysis paralysis** - Don't overthink, read the plan and execute
- **Skipping clarifying questions** - Ask now, not after building wrong thing
- **Ignoring plan references** - The plan has links for a reason
- **Testing at the end** - Test continuously or suffer later
- **Forgetting TodoWrite** - Track progress or lose track of what's done
- **80% done syndrome** - Finish the feature, don't move on early
- **Over-reviewing simple changes** - Save reviewer agents for complex work

---

<task-notification>
<task-id>b5be422</task-id>
<output-file>/private/tmp/claude-501/-Users-weirenlan-Desktop-self-project-labs-openwhisper-mobile/tasks/b5be422.output</output-file>
<status>completed</status>
<summary>Background command "Run expo prebuild to generate iOS project with keyboard extension target" completed (exit code 0)</summary>
</task-notification>
Read the output file to retrieve the result: /private/tmp/claude-501/-Users-weirenlan-Desktop-self-project-labs-openwhisper-mobile/tasks/b5be422.output

---

Âπ´ÊàëÁ¢∫Ë™ç‰∏ã ÊàëÁõÆÂâçÁöÑÁßªÊ§çÂÅöÂÆå‰∫ÜÂóé

---

This session is being continued from a previous conversation that ran out of context. The summary below covers the earlier portion of the conversation.

Analysis:
Let me go through the conversation chronologically:

1. **First user message**: Asked to check alignment between two plan documents:
   - `/Users/weirenlan/Desktop/self_project/labs/openwhisper_mobile/docs/plans/2026-02-12-research-ios-keyboard-extension.md`
   - `/Users/weirenlan/Desktop/self_project/labs/openwhisper_mobile/docs/plans/2026-02-12-feat-ios-react-native-port-plan.md`

2. **My response**: Read both files, performed detailed alignment analysis comparing 15+ topics. Found them well-aligned with 3 minor discrepancies (memory limits, WhisperKit version, Expo SDK reference). Offered to make minor updates.

3. **Second user message**: Ran `/compound-engineering:workflows:plan` on the research document. I tried to ask a clarifying question about what to create (standalone plan, update Phase 7, or new plan from scratch), but the user rejected the AskUserQuestion tool.

4. **Third user message**: Ran `/compound-engineering:workflows:work` on the research document. This triggered the implementation workflow.

5. **Implementation phase**: I read the project state, understood Phases 1-5 were complete, and proceeded to implement Phase 7A (Infrastructure & App Group Setup) based on the research document's Section 9 recommendations and the main plan's Phase 7A task list.

6. **Implementation details**:
   - Installed `@bacons/apple-targets` v4.0.2
   - Created `targets/keyboard/expo-target.config.js`
   - Created `targets/keyboard/KeyboardViewController.swift` (full implementation, not just stub)
   - Created `targets/_shared/Constants.swift`
   - Created `targets/_shared/DictationState.swift`
   - Created `targets/_shared/AppGroupStorage.swift`
   - Updated `app.json` with entitlements, EAS config, AppGroupIdentifier
   - Updated `src/storage/mmkv.ts` for App Group support
   - Created `app/dictate-bridge.tsx` deep link handler
   - Updated `app/_layout.tsx` to register dictate-bridge route
   - Created `src/services/BackgroundDictationService.ts` stub
   - Renamed `modules/whisperkit/WhisperKit.podspec` to `WhisperKitModule.podspec`

7. **Errors encountered**:
   - `cocoapods-spm` gem not installed with new Homebrew CocoaPods
   - System Ruby gem install permission error
   - Found Homebrew Ruby at `/opt/homebrew/opt/ruby/bin/gem`
   - Podspec filename mismatch (WhisperKit.podspec vs WhisperKitModule expected)
   - Deployment target mismatch (Podfile defaulting to 15.1, WhisperKit needs 17.0)
   - cocoapods-spm post_integrate crash on missing xcfilelist files
   - Fixed by creating empty xcfilelist files manually

8. **Commit**: Made commit `57242dd` on `mobile` branch

9. **Background task notification**: prebuild task completed (already handled)

10. **Last user message**: "Âπ´ÊàëÁ¢∫Ë™ç‰∏ã ÊàëÁõÆÂâçÁöÑÁßªÊ§çÂÅöÂÆå‰∫ÜÂóé" (Help me check if my current port is done)

11. **My response**: Read the plan file to show the status of all phases. The conversation ended with the file contents displayed but I hadn't yet provided the summary to the user.

Let me now compile all the specific details needed for the summary.

Summary:
1. Primary Request and Intent:
   - The user initially asked to verify alignment between two plan documents: the keyboard extension research doc and the main iOS React Native port plan.
   - The user then invoked `/workflows:plan` on the research doc (but rejected the clarifying question).
   - The user then invoked `/workflows:work` on the research doc, triggering implementation of Phase 7A (Keyboard Extension Infrastructure & App Group Setup).
   - Finally, the user asked "Âπ´ÊàëÁ¢∫Ë™ç‰∏ã ÊàëÁõÆÂâçÁöÑÁßªÊ§çÂÅöÂÆå‰∫ÜÂóé" (Help me check if my current port is done) ‚Äî wanting a status check across all phases.

2. Key Technical Concepts:
   - **iOS Custom Keyboard Extension**: `com.apple.keyboard-service` extension point, `UIInputViewController`, `RequestsOpenAccess`, no microphone access (permanent Apple restriction)
   - **@bacons/apple-targets v4.0.2**: Expo Config Plugin for managing Apple extension targets, supports `keyboard` type natively, `targets/_shared/` for shared code
   - **App Groups**: `group.com.openwhispr.mobile` for shared `UserDefaults` and file container between main app and keyboard extension
   - **Darwin Notifications**: `CFNotificationCenterGetDarwinNotifyCenter` for real-time cross-process IPC
   - **DictationState State Machine**: idle ‚Üí startRequested ‚Üí recording ‚Üí transcribing ‚Üí complete/error, with session UUIDs for race condition protection
   - **MMKV App Group Integration**: `react-native-mmkv` v4 auto-detects `AppGroupIdentifier` from `Info.plist` and uses the App Group container directory
   - **cocoapods-spm**: CocoaPods plugin for SPM dependency integration (WhisperKit)
   - **Background Audio Session**: Willow-style approach ‚Äî keyboard extension deep-links to main app to activate `AVAudioSession` with `.playAndRecord` category
   - **Expo SDK 54** with development builds, WhisperKit v0.9.4 via cocoapods-spm

3. Files and Code Sections:

   - **`targets/keyboard/expo-target.config.js`** (NEW)
     - Configures the keyboard extension Xcode target for @bacons/apple-targets
     ```javascript
     /** @type {import('@bacons/apple-targets').Config} */
     module.exports = {
       type: "keyboard",
       name: "OpenWhisprKeyboard",
       displayName: "OpenWhispr Voice",
       bundleIdentifier: ".keyboard",
       deploymentTarget: "17.0",
       frameworks: ["UIKit"],
       entitlements: {
         "com.apple.security.application-groups": [
           "group.com.openwhispr.mobile",
         ],
       },
     };
     ```

   - **`targets/keyboard/KeyboardViewController.swift`** (NEW ‚Äî full implementation, not just stub)
     - The main keyboard extension controller with dictation button, next keyboard globe button, status label, Full Access detection/guidance, App Group state observation (0.5s polling + Darwin notifications), session-based text insertion via `textDocumentProxy`, smart whitespace prepending, dark mode support, deep link launching via responder chain
     - Key methods: `setupUI()`, `setupFullAccessGuide()`, `dictateButtonTapped()`, `signalStop()`, `openMainApp(sessionId:)`, `startObserving()`, `checkDictationState()`, `insertTranscribedText(_:)`, `updateUI(for:)`, `resetToIdle()`
     - 371 lines of Swift

   - **`targets/_shared/Constants.swift`** (NEW)
     - Shared constants: App Group ID, UserDefaults keys, Darwin notification names
     ```swift
     enum OpenWhisprConstants {
         static let appGroupIdentifier = "group.com.openwhispr.mobile"
         static let urlScheme = "openwhispr"
         enum Key {
             static let dictationState = "com.openwhispr.dictation_state"
             static let backgroundSessionActive = "com.openwhispr.bg_session_active"
             static let backgroundSessionLastPing = "com.openwhispr.bg_session_ping"
             // ... more keys
         }
         enum Notification {
             static let dictationStateChanged = "com.openwhispr.dictation.stateChanged"
             static let settingsChanged = "com.openwhispr.settings.changed"
         }
     }
     ```

   - **`targets/_shared/DictationState.swift`** (NEW)
     - Codable state machine types for keyboard-to-app IPC
     ```swift
     enum DictationPhase: String, Codable {
         case idle
         case startRequested = "start_requested"
         case recording, transcribing, complete, error
     }
     struct DictationState: Codable {
         let sessionId: String
         let phase: DictationPhase
         let text: String?
         let error: String?
         let timestamp: TimeInterval
         var isStale: Bool { Date().timeIntervalSince1970 - timestamp > 60 }
     }
     ```

   - **`targets/_shared/AppGroupStorage.swift`** (NEW ‚Äî 130 lines)
     - Shared storage API: `getDictationState()`, `setDictationState(_:)`, `clearDictationState()`, `isBackgroundSessionActive` (with heartbeat freshness check), `pingBackgroundSession()`, settings readers, `postDarwinNotification(_:)`, `observeDarwinNotification(_:callback:)` using `DarwinCallbackStore` static dictionary pattern

   - **`app.json`** (MODIFIED)
     - Added `ios.entitlements` with App Group
     - Added `ios.infoPlist.AppGroupIdentifier` for MMKV auto-detection
     - Added `extra.eas.build.experimental.ios.appExtensions` array declaring `OpenWhisprKeyboard`
     - `@bacons/apple-targets` auto-added to plugins by `npx expo install`
     ```json
     "entitlements": {
       "com.apple.security.application-groups": ["group.com.openwhispr.mobile"]
     }
     ```
     ```json
     "AppGroupIdentifier": "group.com.openwhispr.mobile"
     ```

   - **`app/_layout.tsx`** (MODIFIED)
     - Added `dictate-bridge` route with `presentation: "fullScreenModal"`, `gestureEnabled: false`

   - **`app/dictate-bridge.tsx`** (NEW ‚Äî 128 lines)
     - Deep link handler for `openwhispr://dictate?session=<uuid>`, parses session param, shows stub recording UI with "Return to App" button. Phase 7C will add actual BackgroundDictationService integration.

   - **`src/services/BackgroundDictationService.ts`** (NEW ‚Äî stub, 75 lines)
     - Exports `startDictationSession(_sessionId)`, `stopDictationSession()`, `isBackgroundSessionActive()` ‚Äî all stubs for Phase 7C implementation
     - Includes TypeScript types matching Swift: `DictationPhase`, `DictationState`

   - **`src/storage/mmkv.ts`** (MODIFIED)
     - Updated comments to document App Group auto-detection. The actual MMKV config is unchanged because `react-native-mmkv` v4 reads `AppGroupIdentifier` from `Info.plist` automatically.
     ```typescript
     export const storage: MMKV = createMMKV({
       id: "openwhispr-settings",
       encryptionKey: "openwhispr-v1",
     });
     ```

   - **`modules/whisperkit/WhisperKitModule.podspec`** (RENAMED from `WhisperKit.podspec`)
     - Renamed to match pod name `WhisperKitModule` (CocoaPods expects filename to match `s.name`)

   - **`ios/Podfile.properties.json`** (MODIFIED in ios/ generated dir)
     - Added `"ios.deploymentTarget": "17.0"` to fix WhisperKit compatibility

   - **`docs/plans/2026-02-12-feat-ios-react-native-port-plan.md`** (MODIFIED)
     - Checked off 9 of 10 Phase 7A tasks (all except shared Keychain access group)

   - **`docs/plans/2026-02-12-research-ios-keyboard-extension.md`** (READ ONLY)
     - 1083-line research document covering Apple Keyboard Extension architecture, Expo Config Plugin patterns, @bacons/apple-targets, WhisperKit SPM integration options, App Groups, shared frameworks, EAS Build considerations, microphone workarounds, and recommended implementation approach

4. Errors and Fixes:
   - **`cocoapods-spm` gem not installed**: After Homebrew installed fresh CocoaPods 1.16.2, the `spm_pkg` method was undefined. Fixed by finding Homebrew Ruby at `/opt/homebrew/opt/ruby/bin/gem` and running `gem install cocoapods-spm`.
   - **System Ruby permission error**: `gem install cocoapods-spm` failed with `Gem::FilePermissionError` on `/Library/Ruby/Gems/2.6.0`. Fixed by using Homebrew Ruby's gem binary instead.
   - **Podspec filename mismatch**: `No podspec found for 'WhisperKitModule' in '../modules/whisperkit'`. The file was named `WhisperKit.podspec` but pod name was `WhisperKitModule`. Fixed by renaming to `WhisperKitModule.podspec`.
   - **Deployment target mismatch**: `Specs satisfying the WhisperKitModule dependency required a higher minimum deployment target`. The Podfile defaulted to iOS 15.1 from `Podfile.properties.json`. Fixed by adding `"ios.deploymentTarget": "17.0"` to `Podfile.properties.json`.
   - **cocoapods-spm post_integrate crash**: `Errno::ENOENT - No such file or directory @ rb_sysopen - .../Pods-OpenWhispr-resources-Debug-input-files.xcfilelist`. Known cocoapods-spm 0.1.20 bug where it tries to open xcfilelist files that don't exist. Fixed by manually creating the 4 empty xcfilelist files with `touch`, then re-running `pod install`.
   - **Homebrew Ruby gem path conflict**: `Could not find 'minitest'` when trying to use mixed GEM_PATH. Fixed by running `pod install` with default paths after the gems were properly installed.

5. Problem Solving:
   - Alignment analysis between research doc and main plan confirmed architectural consistency across 15+ topics
   - Discovered `react-native-mmkv` v4 auto-detects App Group via `AppGroupIdentifier` in `Info.plist` (read from `REDACTED.swift`) ‚Äî no need for manual path resolution
   - Successfully generated two Xcode targets (`OpenWhispr` + `OpenWhisprKeyboard`) verified via `xcodebuild -list`
   - Verified App Group entitlements in both `OpenWhispr.entitlements` and `targets/keyboard/generated.entitlements`
   - Pod install completed with 92 dependencies after workarounds

6. All User Messages:
   - Message 1 (via `/workflows:plan`): "Ë´ã‰Ω†Âπ´ÊàëÁ¢∫Ë™çÊàëÁöÑÈÄôÂÄãË¶èÂäÉ /Users/weirenlan/Desktop/self_project/labs/openwhisper_mobile/docs/plans/2026-02-12-research-ios-keyboard-extension.md ÊòØÂê¶Ë∑ü /Users/weirenlan/Desktop/self_project/labs/openwhisper_mobile/docs/plans/2026-02-12-feat-ios-react-native-port-plan.md Â∞çÈΩä"
   - Message 2 (via `/workflows:plan`): Invoked `/workflows:plan` on the research document path
   - Message 3: Rejected the AskUserQuestion tool (didn't want to answer the clarifying question about plan scope)
   - Message 4 (via `/workflows:work`): Invoked `/workflows:work` on the research document path ‚Äî triggering implementation
   - Message 5: Background task notification about prebuild completion
   - Message 6: "Âπ´ÊàëÁ¢∫Ë™ç‰∏ã ÊàëÁõÆÂâçÁöÑÁßªÊ§çÂÅöÂÆå‰∫ÜÂóé" (Help me check if my current port is done)

7. Pending Tasks:
   - **Phase 5 remaining unchecked items**: audio cues, edge case handling, VoiceOver accessibility, app icons/splash screen, EAS Build setup
   - **Phase 6**: Authentication + Cloud Features (all items unchecked, marked "Optional for v1")
   - **Phase 7A remaining**: Shared Keychain access group entitlement for API key sharing
   - **Phase 7B**: Keyboard Extension UI polish (SwiftUI hosting, haptics, animations) ‚Äî note: much of this was already implemented in the KeyboardViewController.swift created during 7A
   - **Phase 7C**: BackgroundDictationService full implementation (recording, transcription, App Group write, silence detection, heartbeat)
   - **Phase 7D**: Settings sync, onboarding keyboard step, database source column
   - **Phase 7E**: Physical device testing, edge cases, memory profiling, App Store readiness
   - The user's last question about "ÊòØÂê¶ÂÅöÂÆå‰∫Ü" (is it done) needs to be answered

8. Current Work:
   The user asked "Âπ´ÊàëÁ¢∫Ë™ç‰∏ã ÊàëÁõÆÂâçÁöÑÁßªÊ§çÂÅöÂÆå‰∫ÜÂóé" (Help me check if my current port is done). I read the plan file to show the Phase 7A-7E status, displaying lines 621-790 which show Phase 7A is mostly done (9/10 tasks checked), and Phases 7B through 7E are entirely unchecked. I had also shown earlier that Phases 1-4 are fully checked, Phase 5 has several unchecked items, and Phase 6 is entirely unchecked. The summary/answer to the user had not yet been provided when the conversation was interrupted for this summary request.

   The commit `57242dd` on branch `mobile` contains all Phase 7A work. Git status shows many deleted desktop Electron files (moved to `reference/`) that are unstaged from previous work.

9. Optional Next Step:
   Provide the user with a clear status summary answering their question "Âπ´ÊàëÁ¢∫Ë™ç‰∏ã ÊàëÁõÆÂâçÁöÑÁßªÊ§çÂÅöÂÆå‰∫ÜÂóé". The answer is: **No, the port is not complete.** 
   
   Status by phase:
   - Phase 1-4: Code complete (a few testing items unchecked)
   - Phase 5: Core features done, but edge cases/accessibility/app icons/EAS Build remaining
   - Phase 6: Not started (optional for v1)
   - Phase 7A: Just completed (9/10 tasks)
   - Phase 7B-7E: Not started

   The user's exact quote was: "Âπ´ÊàëÁ¢∫Ë™ç‰∏ã ÊàëÁõÆÂâçÁöÑÁßªÊ§çÂÅöÂÆå‰∫ÜÂóé"

If you need specific details from before compaction (like exact code snippets, error messages, or content you generated), read the full transcript at: /Users/weirenlan/.REDACTED.jsonl
Please continue the conversation from where we left off without asking the user any further questions. Continue with the last task that you were asked to work on.

---

Âπ´ÊàëÊääÁõÆÂâçÂÆåÊàêÁöÑÁãÄÊÖãÊõ¥Êñ∞Âà∞plan‰∏ä

---

# Work Plan Execution Command

Execute a work plan efficiently while maintaining quality and finishing features.

## Introduction

This command takes a work document (plan, specification, or todo file) and executes it systematically. The focus is on **shipping complete features** by understanding requirements quickly, following existing patterns, and maintaining quality throughout.

## Input Document

<input_document> #| **2** | WhisperKit Integration | Done | ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë ~90% (cellular warning, multi-device test pending) | </input_document>

## Execution Workflow

### Phase 1: Quick Start

1. **Read Plan and Clarify**

   - Read the work document completely
   - Review any references or links provided in the plan
   - If anything is unclear or ambiguous, ask clarifying questions now
   - Get user approval to proceed
   - **Do not skip this** - better to ask questions now than build the wrong thing

2. **Setup Environment**

   First, check the current branch:

   ```bash
   current_branch=$(git branch --show-current)
   default_branch=$(git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/remotes/origin/@@')

   # Fallback if remote HEAD isn't set
   if [ -z "$default_branch" ]; then
     default_branch=$(git rev-parse --verify origin/main >/dev/null 2>&1 && echo "main" || echo "master")
   fi
   ```

   **If already on a feature branch** (not the default branch):
   - Ask: "Continue working on `[current_branch]`, or create a new branch?"
   - If continuing, proceed to step 3
   - If creating new, follow Option A or B below

   **If on the default branch**, choose how to proceed:

   **Option A: Create a new branch**
   ```bash
   git pull origin [default_branch]
   git checkout -b feature-branch-name
   ```
   Use a meaningful name based on the work (e.g., `feat/user-authentication`, `fix/email-validation`).

   **Option B: Use a worktree (recommended for parallel development)**
   ```bash
   skill: git-worktree
   # The skill will create a new branch from the default branch in an isolated worktree
   ```

   **Option C: Continue on the default branch**
   - Requires explicit user confirmation
   - Only proceed after user explicitly says "yes, commit to [default_branch]"
   - Never commit directly to the default branch without explicit permission

   **Recommendation**: Use worktree if:
   - You want to work on multiple features simultaneously
   - You want to keep the default branch clean while experimenting
   - You plan to switch between branches frequently

3. **Create Todo List**
   - Use TodoWrite to break plan into actionable tasks
   - Include dependencies between tasks
   - Prioritize based on what needs to be done first
   - Include testing and quality check tasks
   - Keep tasks specific and completable

### Phase 2: Execute

1. **Task Execution Loop**

   For each task in priority order:

   ```
   while (tasks remain):
     - Mark task as in_progress in TodoWrite
     - Read any referenced files from the plan
     - Look for similar patterns in codebase
     - Implement following existing conventions
     - Write tests for new functionality
     - Run tests after changes
     - Mark task as completed in TodoWrite
     - Mark off the corresponding checkbox in the plan file ([ ] ‚Üí [x])
     - Evaluate for incremental commit (see below)
   ```

   **IMPORTANT**: Always update the original plan document by checking off completed items. Use the Edit tool to change `- [ ]` to `- [x]` for each task you finish. This keeps the plan as a living document showing progress and ensures no checkboxes are left unchecked.

2. **Incremental Commits**

   After completing each task, evaluate whether to create an incremental commit:

   | Commit when... | Don't commit when... |
   |----------------|---------------------|
   | Logical unit complete (model, service, component) | Small part of a larger unit |
   | Tests pass + meaningful progress | Tests failing |
   | About to switch contexts (backend ‚Üí frontend) | Purely scaffolding with no behavior |
   | About to attempt risky/uncertain changes | Would need a "WIP" commit message |

   **Heuristic:** "Can I write a commit message that describes a complete, valuable change? If yes, commit. If the message would be 'WIP' or 'partial X', wait."

   **Commit workflow:**
   ```bash
   # 1. Verify tests pass (use project's test command)
   # Examples: bin/rails test, npm test, pytest, go test, etc.

   # 2. Stage only files related to this logical unit (not `git add .`)
   git add <files related to this logical unit>

   # 3. Commit with conventional message
   git commit -m "feat(scope): description of this unit"
   ```

   **Handling merge conflicts:** If conflicts arise during rebasing or merging, resolve them immediately. Incremental commits make conflict resolution easier since each commit is small and focused.

   **Note:** Incremental commits use clean conventional messages without attribution footers. The final Phase 4 commit/PR includes the full attribution.

3. **Follow Existing Patterns**

   - The plan should reference similar code - read those files first
   - Match naming conventions exactly
   - Reuse existing components where possible
   - Follow project coding standards (see CLAUDE.md)
   - When in doubt, grep for similar implementations

4. **Test Continuously**

   - Run relevant tests after each significant change
   - Don't wait until the end to test
   - Fix failures immediately
   - Add new tests for new functionality

5. **Figma Design Sync** (if applicable)

   For UI work with Figma designs:

   - Implement components following design specs
   - Use figma-design-sync agent iteratively to compare
   - Fix visual differences identified
   - Repeat until implementation matches design

6. **Track Progress**
   - Keep TodoWrite updated as you complete tasks
   - Note any blockers or unexpected discoveries
   - Create new tasks if scope expands
   - Keep user informed of major milestones

### Phase 3: Quality Check

1. **Run Core Quality Checks**

   Always run before submitting:

   ```bash
   # Run full test suite (use project's test command)
   # Examples: bin/rails test, npm test, pytest, go test, etc.

   # Run linting (per CLAUDE.md)
   # Use linting-agent before pushing to origin
   ```

2. **Consider Reviewer Agents** (Optional)

   Use for complex, risky, or large changes:

   - **code-simplicity-reviewer**: Check for unnecessary complexity
   - **kieran-rails-reviewer**: Verify Rails conventions (Rails projects)
   - **performance-oracle**: Check for performance issues
   - **security-sentinel**: Scan for security vulnerabilities
   - **cora-test-reviewer**: Review test quality (Rails projects with comprehensive test coverage)

   Run reviewers in parallel with Task tool:

   ```
   Task(code-simplicity-reviewer): "Review changes for simplicity"
   Task(kieran-rails-reviewer): "Check Rails conventions"
   ```

   Present findings to user and address critical issues.

3. **Final Validation**
   - All TodoWrite tasks marked completed
   - All tests pass
   - Linting passes
   - Code follows existing patterns
   - Figma designs match (if applicable)
   - No console errors or warnings

### Phase 4: Ship It

1. **Create Commit**

   ```bash
   git add .
   git status  # Review what's being committed
   git diff --staged  # Check the changes

   # Commit with conventional format
   git commit -m "$(cat <<'EOF'
   feat(scope): description of what and why

   Brief explanation if needed.

   ü§ñ Generated with [Claude Code](https://claude.com/claude-code)

   Co-Authored-By: Claude <noreply@anthropic.com>
   EOF
   )"
   ```

2. **Capture and Upload Screenshots for UI Changes** (REQUIRED for any UI work)

   For **any** design changes, new views, or UI modifications, you MUST capture and upload screenshots:

   **Step 1: Start dev server** (if not running)
   ```bash
   bin/dev  # Run in background
   ```

   **Step 2: Capture screenshots with agent-browser CLI**
   ```bash
   agent-browser open http://localhost:3000/[route]
   agent-browser snapshot -i
   agent-browser screenshot output.png
   ```
   See the `agent-browser` skill for detailed usage.

   **Step 3: Upload using imgup skill**
   ```bash
   skill: imgup
   # Then upload each screenshot:
   imgup -h pixhost screenshot.png  # pixhost works without API key
   # Alternative hosts: catbox, imagebin, beeimg
   ```

   **What to capture:**
   - **New screens**: Screenshot of the new UI
   - **Modified screens**: Before AND after screenshots
   - **Design implementation**: Screenshot showing Figma design match

   **IMPORTANT**: Always include uploaded image URLs in PR description. This provides visual context for reviewers and documents the change.

3. **Create Pull Request**

   ```bash
   git push -u origin feature-branch-name

   gh pr create --title "Feature: [Description]" --body "$(cat <<'EOF'
   ## Summary
   - What was built
   - Why it was needed
   - Key decisions made

   ## Testing
   - Tests added/modified
   - Manual testing performed

   ## Before / After Screenshots
   | Before | After |
   |--------|-------|
   | ![before](URL) | ![after](URL) |

   ## Figma Design
   [Link if applicable]

   ---

   [![Compound Engineered](https://img.shields.io/badge/Compound-Engineered-6366f1)](https://github.com/EveryInc/compound-engineering-plugin) ü§ñ Generated with [Claude Code](https://claude.com/claude-code)
   EOF
   )"
   ```

4. **Notify User**
   - Summarize what was completed
   - Link to PR
   - Note any follow-up work needed
   - Suggest next steps if applicable

---

## Key Principles

### Start Fast, Execute Faster

- Get clarification once at the start, then execute
- Don't wait for perfect understanding - ask questions and move
- The goal is to **finish the feature**, not create perfect process

### The Plan is Your Guide

- Work documents should reference similar code and patterns
- Load those references and follow them
- Don't reinvent - match what exists

### Test As You Go

- Run tests after each change, not at the end
- Fix failures immediately
- Continuous testing prevents big surprises

### Quality is Built In

- Follow existing patterns
- Write tests for new code
- Run linting before pushing
- Use reviewer agents for complex/risky changes only

### Ship Complete Features

- Mark all tasks completed before moving on
- Don't leave features 80% done
- A finished feature that ships beats a perfect feature that doesn't

## Quality Checklist

Before creating PR, verify:

- [ ] All clarifying questions asked and answered
- [ ] All TodoWrite tasks marked completed
- [ ] Tests pass (run project's test command)
- [ ] Linting passes (use linting-agent)
- [ ] Code follows existing patterns
- [ ] Figma designs match implementation (if applicable)
- [ ] Before/after screenshots captured and uploaded (for UI changes)
- [ ] Commit messages follow conventional format
- [ ] PR description includes summary, testing notes, and screenshots
- [ ] PR description includes Compound Engineered badge

## When to Use Reviewer Agents

**Don't use by default.** Use reviewer agents only when:

- Large refactor affecting many files (10+)
- Security-sensitive changes (authentication, permissions, data access)
- Performance-critical code paths
- Complex algorithms or business logic
- User explicitly requests thorough review

For most features: tests + linting + following patterns is sufficient.

## Common Pitfalls to Avoid

- **Analysis paralysis** - Don't overthink, read the plan and execute
- **Skipping clarifying questions** - Ask now, not after building wrong thing
- **Ignoring plan references** - The plan has links for a reason
- **Testing at the end** - Test continuously or suffer later
- **Forgetting TodoWrite** - Track progress or lose track of what's done
- **80% done syndrome** - Finish the feature, don't move on early
- **Over-reviewing simple changes** - Save reviewer agents for complex work

---

# Work Plan Execution Command

Execute a work plan efficiently while maintaining quality and finishing features.

## Introduction

This command takes a work document (plan, specification, or todo file) and executes it systematically. The focus is on **shipping complete features** by understanding requirements quickly, following existing patterns, and maintaining quality throughout.

## Input Document

<input_document> #docs/plans/2026-02-12-feat-ios-react-native-port-plan.md "Implement Phase 5: Settings, onboarding, theme, error handling, accessibility" Âπ´ÊàëÊääÈÇÑÊ≤íÂÅöÂÆåÁöÑÈÉ®ÂàÜÂÆåÊàê </input_document>

## Execution Workflow

### Phase 1: Quick Start

1. **Read Plan and Clarify**

   - Read the work document completely
   - Review any references or links provided in the plan
   - If anything is unclear or ambiguous, ask clarifying questions now
   - Get user approval to proceed
   - **Do not skip this** - better to ask questions now than build the wrong thing

2. **Setup Environment**

   First, check the current branch:

   ```bash
   current_branch=$(git branch --show-current)
   default_branch=$(git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/remotes/origin/@@')

   # Fallback if remote HEAD isn't set
   if [ -z "$default_branch" ]; then
     default_branch=$(git rev-parse --verify origin/main >/dev/null 2>&1 && echo "main" || echo "master")
   fi
   ```

   **If already on a feature branch** (not the default branch):
   - Ask: "Continue working on `[current_branch]`, or create a new branch?"
   - If continuing, proceed to step 3
   - If creating new, follow Option A or B below

   **If on the default branch**, choose how to proceed:

   **Option A: Create a new branch**
   ```bash
   git pull origin [default_branch]
   git checkout -b feature-branch-name
   ```
   Use a meaningful name based on the work (e.g., `feat/user-authentication`, `fix/email-validation`).

   **Option B: Use a worktree (recommended for parallel development)**
   ```bash
   skill: git-worktree
   # The skill will create a new branch from the default branch in an isolated worktree
   ```

   **Option C: Continue on the default branch**
   - Requires explicit user confirmation
   - Only proceed after user explicitly says "yes, commit to [default_branch]"
   - Never commit directly to the default branch without explicit permission

   **Recommendation**: Use worktree if:
   - You want to work on multiple features simultaneously
   - You want to keep the default branch clean while experimenting
   - You plan to switch between branches frequently

3. **Create Todo List**
   - Use TodoWrite to break plan into actionable tasks
   - Include dependencies between tasks
   - Prioritize based on what needs to be done first
   - Include testing and quality check tasks
   - Keep tasks specific and completable

### Phase 2: Execute

1. **Task Execution Loop**

   For each task in priority order:

   ```
   while (tasks remain):
     - Mark task as in_progress in TodoWrite
     - Read any referenced files from the plan
     - Look for similar patterns in codebase
     - Implement following existing conventions
     - Write tests for new functionality
     - Run tests after changes
     - Mark task as completed in TodoWrite
     - Mark off the corresponding checkbox in the plan file ([ ] ‚Üí [x])
     - Evaluate for incremental commit (see below)
   ```

   **IMPORTANT**: Always update the original plan document by checking off completed items. Use the Edit tool to change `- [ ]` to `- [x]` for each task you finish. This keeps the plan as a living document showing progress and ensures no checkboxes are left unchecked.

2. **Incremental Commits**

   After completing each task, evaluate whether to create an incremental commit:

   | Commit when... | Don't commit when... |
   |----------------|---------------------|
   | Logical unit complete (model, service, component) | Small part of a larger unit |
   | Tests pass + meaningful progress | Tests failing |
   | About to switch contexts (backend ‚Üí frontend) | Purely scaffolding with no behavior |
   | About to attempt risky/uncertain changes | Would need a "WIP" commit message |

   **Heuristic:** "Can I write a commit message that describes a complete, valuable change? If yes, commit. If the message would be 'WIP' or 'partial X', wait."

   **Commit workflow:**
   ```bash
   # 1. Verify tests pass (use project's test command)
   # Examples: bin/rails test, npm test, pytest, go test, etc.

   # 2. Stage only files related to this logical unit (not `git add .`)
   git add <files related to this logical unit>

   # 3. Commit with conventional message
   git commit -m "feat(scope): description of this unit"
   ```

   **Handling merge conflicts:** If conflicts arise during rebasing or merging, resolve them immediately. Incremental commits make conflict resolution easier since each commit is small and focused.

   **Note:** Incremental commits use clean conventional messages without attribution footers. The final Phase 4 commit/PR includes the full attribution.

3. **Follow Existing Patterns**

   - The plan should reference similar code - read those files first
   - Match naming conventions exactly
   - Reuse existing components where possible
   - Follow project coding standards (see CLAUDE.md)
   - When in doubt, grep for similar implementations

4. **Test Continuously**

   - Run relevant tests after each significant change
   - Don't wait until the end to test
   - Fix failures immediately
   - Add new tests for new functionality

5. **Figma Design Sync** (if applicable)

   For UI work with Figma designs:

   - Implement components following design specs
   - Use figma-design-sync agent iteratively to compare
   - Fix visual differences identified
   - Repeat until implementation matches design

6. **Track Progress**
   - Keep TodoWrite updated as you complete tasks
   - Note any blockers or unexpected discoveries
   - Create new tasks if scope expands
   - Keep user informed of major milestones

### Phase 3: Quality Check

1. **Run Core Quality Checks**

   Always run before submitting:

   ```bash
   # Run full test suite (use project's test command)
   # Examples: bin/rails test, npm test, pytest, go test, etc.

   # Run linting (per CLAUDE.md)
   # Use linting-agent before pushing to origin
   ```

2. **Consider Reviewer Agents** (Optional)

   Use for complex, risky, or large changes:

   - **code-simplicity-reviewer**: Check for unnecessary complexity
   - **kieran-rails-reviewer**: Verify Rails conventions (Rails projects)
   - **performance-oracle**: Check for performance issues
   - **security-sentinel**: Scan for security vulnerabilities
   - **cora-test-reviewer**: Review test quality (Rails projects with comprehensive test coverage)

   Run reviewers in parallel with Task tool:

   ```
   Task(code-simplicity-reviewer): "Review changes for simplicity"
   Task(kieran-rails-reviewer): "Check Rails conventions"
   ```

   Present findings to user and address critical issues.

3. **Final Validation**
   - All TodoWrite tasks marked completed
   - All tests pass
   - Linting passes
   - Code follows existing patterns
   - Figma designs match (if applicable)
   - No console errors or warnings

### Phase 4: Ship It

1. **Create Commit**

   ```bash
   git add .
   git status  # Review what's being committed
   git diff --staged  # Check the changes

   # Commit with conventional format
   git commit -m "$(cat <<'EOF'
   feat(scope): description of what and why

   Brief explanation if needed.

   ü§ñ Generated with [Claude Code](https://claude.com/claude-code)

   Co-Authored-By: Claude <noreply@anthropic.com>
   EOF
   )"
   ```

2. **Capture and Upload Screenshots for UI Changes** (REQUIRED for any UI work)

   For **any** design changes, new views, or UI modifications, you MUST capture and upload screenshots:

   **Step 1: Start dev server** (if not running)
   ```bash
   bin/dev  # Run in background
   ```

   **Step 2: Capture screenshots with agent-browser CLI**
   ```bash
   agent-browser open http://localhost:3000/[route]
   agent-browser snapshot -i
   agent-browser screenshot output.png
   ```
   See the `agent-browser` skill for detailed usage.

   **Step 3: Upload using imgup skill**
   ```bash
   skill: imgup
   # Then upload each screenshot:
   imgup -h pixhost screenshot.png  # pixhost works without API key
   # Alternative hosts: catbox, imagebin, beeimg
   ```

   **What to capture:**
   - **New screens**: Screenshot of the new UI
   - **Modified screens**: Before AND after screenshots
   - **Design implementation**: Screenshot showing Figma design match

   **IMPORTANT**: Always include uploaded image URLs in PR description. This provides visual context for reviewers and documents the change.

3. **Create Pull Request**

   ```bash
   git push -u origin feature-branch-name

   gh pr create --title "Feature: [Description]" --body "$(cat <<'EOF'
   ## Summary
   - What was built
   - Why it was needed
   - Key decisions made

   ## Testing
   - Tests added/modified
   - Manual testing performed

   ## Before / After Screenshots
   | Before | After |
   |--------|-------|
   | ![before](URL) | ![after](URL) |

   ## Figma Design
   [Link if applicable]

   ---

   [![Compound Engineered](https://img.shields.io/badge/Compound-Engineered-6366f1)](https://github.com/EveryInc/compound-engineering-plugin) ü§ñ Generated with [Claude Code](https://claude.com/claude-code)
   EOF
   )"
   ```

4. **Notify User**
   - Summarize what was completed
   - Link to PR
   - Note any follow-up work needed
   - Suggest next steps if applicable

---

## Key Principles

### Start Fast, Execute Faster

- Get clarification once at the start, then execute
- Don't wait for perfect understanding - ask questions and move
- The goal is to **finish the feature**, not create perfect process

### The Plan is Your Guide

- Work documents should reference similar code and patterns
- Load those references and follow them
- Don't reinvent - match what exists

### Test As You Go

- Run tests after each change, not at the end
- Fix failures immediately
- Continuous testing prevents big surprises

### Quality is Built In

- Follow existing patterns
- Write tests for new code
- Run linting before pushing
- Use reviewer agents for complex/risky changes only

### Ship Complete Features

- Mark all tasks completed before moving on
- Don't leave features 80% done
- A finished feature that ships beats a perfect feature that doesn't

## Quality Checklist

Before creating PR, verify:

- [ ] All clarifying questions asked and answered
- [ ] All TodoWrite tasks marked completed
- [ ] Tests pass (run project's test command)
- [ ] Linting passes (use linting-agent)
- [ ] Code follows existing patterns
- [ ] Figma designs match implementation (if applicable)
- [ ] Before/after screenshots captured and uploaded (for UI changes)
- [ ] Commit messages follow conventional format
- [ ] PR description includes summary, testing notes, and screenshots
- [ ] PR description includes Compound Engineered badge

## When to Use Reviewer Agents

**Don't use by default.** Use reviewer agents only when:

- Large refactor affecting many files (10+)
- Security-sensitive changes (authentication, permissions, data access)
- Performance-critical code paths
- Complex algorithms or business logic
- User explicitly requests thorough review

For most features: tests + linting + following patterns is sufficient.

## Common Pitfalls to Avoid

- **Analysis paralysis** - Don't overthink, read the plan and execute
- **Skipping clarifying questions** - Ask now, not after building wrong thing
- **Ignoring plan references** - The plan has links for a reason
- **Testing at the end** - Test continuously or suffer later
- **Forgetting TodoWrite** - Track progress or lose track of what's done
- **80% done syndrome** - Finish the feature, don't move on early
- **Over-reviewing simple changes** - Save reviewer agents for complex work

---

commit

---

This session is being continued from a previous conversation that ran out of context. The summary below covers the earlier portion of the conversation.

Analysis:
Let me go through the conversation chronologically:

1. **Context from previous session**: The conversation was continued from a previous session. Key context:
   - Working on porting OpenWhispr desktop (Electron) to iOS React Native
   - Phases 1-4 were complete, Phase 5 partially done, Phase 7A mostly done
   - On `mobile` branch
   - Previous session implemented Phase 7A (keyboard extension infrastructure)

2. **First user message**: Asked to check current port status ("Âπ´ÊàëÁ¢∫Ë™ç‰∏ã ÊàëÁõÆÂâçÁöÑÁßªÊ§çÂÅöÂÆå‰∫ÜÂóé")

3. **My response**: Read the plan file and provided a detailed status summary table showing all phases. Concluded the port was not complete with specific remaining items per phase.

4. **Second user message**: "Âπ´ÊàëÊääÁõÆÂâçÂÆåÊàêÁöÑÁãÄÊÖãÊõ¥Êñ∞Âà∞plan‰∏ä" (Update the completed status to the plan)

5. **My response**: 
   - Read the plan file thoroughly
   - Read `KeyboardViewController.swift` to verify which Phase 7B tasks were already implemented during 7A
   - Added a Progress Summary table at the top of the plan
   - Updated Phase 7B tasks to reflect actual completion (5 tasks checked off)
   - Updated Dependencies table
   - Updated Phase 1 note

6. **Third user message**: `/compound-engineering:workflows:work` on Phase 2 remaining tasks

7. **My response for Phase 2**:
   - Identified 3 unchecked Phase 2 tasks: cellular download warning, multi-device testing, device compatibility warnings
   - Installed `expo-network` for network type detection
   - Added `checkNetworkForDownload()` and `getModelCompatibilityWarning()` to WhisperKitService.ts
   - Updated ModelPicker.tsx to integrate both checks into download flow
   - Committed as `550d4c5`

8. **Fourth user message**: `/compound-engineering:workflows:work` on Phase 5 remaining tasks ("Âπ´ÊàëÊääÈÇÑÊ≤íÂÅöÂÆåÁöÑÈÉ®ÂàÜÂÆåÊàê")

9. **My response for Phase 5**: Implemented 5 remaining tasks:
   - **Audio cues**: Created `src/utils/audioCues.ts` with programmatic sine wave generation, integrated into dictate screen and settings
   - **Edge case handling**: Added AppState listener for background transitions in useAudioRecording.ts, added timeout/network error handling in CloudTranscription.ts, added permission re-check in dictate.tsx
   - **VoiceOver accessibility**: Added AccessibilityInfo announcements, accessibilityHint/Label throughout dictate, history, settings screens
   - **App icons/splash**: Added dark mode splash screen config, iOS buildNumber
   - **EAS Build**: Created eas.json with 4 build profiles

   Made 4 incremental commits + 1 plan update commit

10. **Fifth user message**: "commit"

11. **My response**: Checked git status. Found ~200 unstaged file deletions (old desktop Electron files moved to `reference/`), untracked `reference/` directory (1.3GB), untracked research doc, and `.claude/settings.json` change. Was about to create the commit when the summary was requested.

Now let me catalog all the specific files and changes:

**Files created:**
- `src/utils/audioCues.ts` - Audio cue utility with sine wave generation
- `eas.json` - EAS Build configuration

**Files modified:**
- `src/services/WhisperKitService.ts` - Added expo-network import, `checkNetworkForDownload()`, `getModelCompatibilityWarning()`
- `src/components/ModelPicker.tsx` - Added cellular/compatibility checks to download flow
- `app/(tabs)/dictate.tsx` - Added audio cues, permission re-check, VoiceOver announcements, error haptics
- `app/(tabs)/settings.tsx` - Added audio cues toggle, accessibility labels on switches
- `app/(tabs)/history.tsx` - Added accessibility labels/hints throughout
- `src/hooks/useAudioRecording.ts` - Added AppState listener for background handling
- `src/services/CloudTranscription.ts` - Added timeout, network error handling, 401/429 messages
- `app.json` - Added dark splash screen, buildNumber, EAS projectId placeholder
- `docs/plans/2026-02-12-feat-ios-react-native-port-plan.md` - Multiple updates to checkboxes and progress summary
- `package.json` / `package-lock.json` - Added expo-network dependency

**Commits made:**
1. `550d4c5` - feat(whisperkit): add cellular download warning and device compatibility checks
2. `f84ad1b` - feat(polish): add audio cues, edge case handling, and error resilience
3. `51aad5d` - feat(a11y): add VoiceOver accessibility across all screens
4. `5d2d233` - feat(config): add dark mode splash screen and iOS build number
5. `7c5a0ec` - feat(eas): add EAS Build configuration for TestFlight distribution
6. `40e7fed` - docs: mark Phase 5 complete in plan, update progress summary

**Remaining unstaged changes:**
- ~200 deleted desktop Electron files (previously moved to `reference/`)
- `reference/` directory (1.3GB, untracked, contains desktop project copy)
- `docs/plans/2026-02-12-research-ios-keyboard-extension.md` (untracked)
- `.claude/settings.json` (modified)
- `modules/whisperkit/WhisperKit.podspec` (deleted, was renamed to WhisperKitModule.podspec in earlier session)

The user said "commit" and I was in the process of examining what to commit when the summary was requested.

Summary:
1. Primary Request and Intent:
   - The user initially asked to verify the current port status ("Âπ´ÊàëÁ¢∫Ë™ç‰∏ã ÊàëÁõÆÂâçÁöÑÁßªÊ§çÂÅöÂÆå‰∫ÜÂóé")
   - Then asked to update the plan file with the current completion status ("Âπ´ÊàëÊääÁõÆÂâçÂÆåÊàêÁöÑÁãÄÊÖãÊõ¥Êñ∞Âà∞plan‰∏ä")
   - Then invoked `/workflows:work` to complete remaining Phase 2 tasks (cellular download warning, device compatibility warnings)
   - Then invoked `/workflows:work` to complete ALL remaining Phase 5 tasks (audio cues, edge case handling, VoiceOver accessibility, app icons, EAS Build)
   - Finally said "commit" to commit remaining unstaged changes (old desktop Electron file deletions + `reference/` directory)

2. Key Technical Concepts:
   - **React Native / Expo SDK 54** iOS app port from Electron desktop
   - **expo-network** for detecting cellular vs WiFi connections
   - **Programmatic audio cue generation** using sine wave WAV files built in memory via DataView/ArrayBuffer, played through expo-av Sound API
   - **AppState listener** for handling background transitions during recording (graceful stop)
   - **AbortController** for fetch timeout in cloud transcription (60s)
   - **AccessibilityInfo.announceForAccessibility()** for VoiceOver live announcements
   - **EAS Build** configuration with development, preview, and production profiles
   - **MMKV storage** for audio cues toggle setting
   - **WhisperKit** model size comparison for device compatibility warnings
   - iOS Custom Keyboard Extension via `@bacons/apple-targets`

3. Files and Code Sections:

   - **`src/services/WhisperKitService.ts`** (MODIFIED)
     - Added cellular download warning and device compatibility checking functions
     - Key additions:
     ```typescript
     import * as Network from "expo-network";
     
     const CELLULAR_WARNING_THRESHOLD = 100 * 1024 * 1024; // 100 MB
     
     export async function checkNetworkForDownload(
       modelSizeBytes: number
     ): Promise<{ shouldWarn: boolean; networkType: string }> {
       try {
         const networkState = await Network.getNetworkStateAsync();
         const isCellular = networkState.type === Network.NetworkStateType.CELLULAR;
         return {
           shouldWarn: isCellular && modelSizeBytes > CELLULAR_WARNING_THRESHOLD,
           networkType: isCellular ? "cellular" : "wifi",
         };
       } catch {
         return { shouldWarn: false, networkType: "unknown" };
       }
     }
     
     export async function getModelCompatibilityWarning(
       modelName: string,
       modelSizeBytes: number,
       recommendedModel: string | null
     ): Promise<string | null> {
       if (!recommendedModel) return null;
       try {
         const models = await WhisperKitModule.getAvailableModels();
         const recommended = models.find((m) => m.name === recommendedModel);
         if (!recommended) return null;
         if (modelSizeBytes > recommended.sizeBytes * 2) {
           return `This model (${formatBytes(modelSizeBytes)}) is much larger than the recommended model for your device (${recommended.displayName}, ${formatBytes(recommended.sizeBytes)}). It may cause slow transcription or memory issues.`;
         }
       } catch {}
       return null;
     }
     ```

   - **`src/components/ModelPicker.tsx`** (MODIFIED)
     - Added `recommendedModel` prop to `ModelRow`, integrated cellular + compatibility checks into `handleDownload`
     - Shows combined Alert with "Download Anyway" / "Cancel" when warnings triggered
     ```typescript
     const handleDownload = useCallback(async () => {
       const { hasSpace, availableBytes } = await checkDiskSpaceForModel(model.sizeBytes);
       if (!hasSpace) { Alert.alert(...); return; }
       const compatWarning = await getModelCompatibilityWarning(model.name, model.sizeBytes, recommendedModel);
       const { shouldWarn: cellularWarn } = await checkNetworkForDownload(model.sizeBytes);
       const warnings: string[] = [];
       if (compatWarning) warnings.push(compatWarning);
       if (cellularWarn) warnings.push(`You're on cellular data. This download is ${formatBytes(model.sizeBytes)}.`);
       if (warnings.length > 0) {
         Alert.alert(cellularWarn ? "Download on Cellular?" : "Large Model Warning", warnings.join("\n\n"),
           [{ text: "Cancel", style: "cancel" }, { text: "Download Anyway", onPress: onDownload }]);
         return;
       }
       onDownload();
     }, [model.sizeBytes, model.name, recommendedModel, onDownload]);
     ```

   - **`src/utils/audioCues.ts`** (NEW - 107 lines)
     - Programmatic sine wave tone generation without bundled audio files
     - `playStartCue()` (880Hz, 120ms), `playStopCue()` (660Hz, 150ms)
     - Generates WAV in memory via ArrayBuffer/DataView, plays via expo-av Sound
     - `areAudioCuesEnabled()` / `setAudioCuesEnabled()` backed by MMKV storage
     - Fade-in/fade-out envelope to prevent clicks
     - Non-blocking ‚Äî errors never interrupt the user

   - **`app/(tabs)/dictate.tsx`** (MODIFIED)
     - Added audio cues: `playStartCue()` on recording start, `playStopCue()` on stop
     - Added permission re-check before recording (microphone !== "granted")
     - Added haptic error feedback on transcription failure
     - Added VoiceOver announcements via `AccessibilityInfo.announceForAccessibility()`
     - Added `accessibilityHint` to copy/share buttons

   - **`app/(tabs)/settings.tsx`** (MODIFIED)
     - Added audio cues toggle in Appearance section with Switch component
     - Added `accessibilityLabel` to all Switch components (local model, AI processing, audio cues)
     - Added useState for audioCues state, imports for `areAudioCuesEnabled`/`setAudioCuesEnabled`
     - Removed unused `Pressable` import

   - **`app/(tabs)/history.tsx`** (MODIFIED)
     - Added combined `accessibilityLabel` for TranscriptionItem (date + text + badges)
     - Added `accessibilityHint="Tap to view full transcription"` on items
     - Added `importantForAccessibility="no"` on child text to prevent duplicate reading
     - Added `accessibilityLabel`/`accessibilityRole` on detail view buttons (back, copy, share, delete)
     - Added `accessibilityLabel`/`accessibilityHint` on search field

   - **`src/hooks/useAudioRecording.ts`** (MODIFIED)
     - Added AppState import and listener for background transitions
     ```typescript
     useEffect(() => {
       const handleAppStateChange = (nextState: AppStateStatus) => {
         if (nextState === "background" || nextState === "inactive") {
           if (recordingRef.current) {
             stopRecording().catch(() => { cancelRecording(); });
           }
         }
       };
       const sub = AppState.addEventListener("change", handleAppStateChange);
       return () => sub.remove();
     }, [stopRecording, cancelRecording]);
     ```

   - **`src/services/CloudTranscription.ts`** (MODIFIED)
     - Added 60s timeout via AbortController
     - Added user-friendly error messages for network errors, 401 (invalid API key), 429 (rate limit)
     ```typescript
     const controller = new AbortController();
     const timeout = setTimeout(() => controller.abort(), 60_000);
     try {
       response = await fetch(endpoint, { ...options, signal: controller.signal });
     } catch (err) {
       clearTimeout(timeout);
       if (err instanceof Error && err.name === "AbortError") {
         throw new Error("Cloud transcription timed out...");
       }
       throw new Error("Network error ‚Äî could not reach transcription service...");
     } finally { clearTimeout(timeout); }
     ```

   - **`app.json`** (MODIFIED)
     - Added dark mode splash screen: `"dark": { "backgroundColor": "#000000" }`
     - Added `"buildNumber": "1"` to iOS config
     - Added `"projectId": ""` placeholder in `extra.eas`

   - **`eas.json`** (NEW)
     - 4 build profiles: `development` (physical device), `development-simulator`, `preview` (internal TestFlight), `production` (auto-increment)
     - Submit config placeholder for App Store

   - **`docs/plans/2026-02-12-feat-ios-react-native-port-plan.md`** (MODIFIED multiple times)
     - Added Progress Summary table at top with visual progress bars
     - Checked off Phase 2 tasks: cellular warning, device compatibility
     - Checked off all Phase 5 tasks: audio cues, edge cases, VoiceOver, icons, EAS Build
     - Updated Phase 7B tasks to reflect actual implementation from 7A
     - Updated Dependencies table
     - Updated v1/v2 completion percentages

4. Errors and fixes:
   - No errors encountered in this session. All TypeScript checks passed (`npx tsc --noEmit` returned clean every time).
   - `expo-doctor` showed a pre-existing warning about `ios.deploymentTarget` in app.json (not a valid top-level field per schema), but this was a known issue not related to changes made.

5. Problem Solving:
   - **Audio cues without bundled files**: Desktop had no sound files to port. Solved by generating WAV files programmatically in memory using sine wave math + DataView for WAV header construction, then playing via expo-av Sound API.
   - **Device compatibility**: Used WhisperKit's `getRecommendedModel()` as the baseline ‚Äî warns when a model is >2x larger than the device recommendation.
   - **Cellular detection**: Used `expo-network` `getNetworkStateAsync()` with graceful fallback if network type can't be determined.
   - **Background recording loss**: Added AppState listener that gracefully stops recording when app goes to background, with fallback to cancel if stop fails.

6. All user messages:
   - "Âπ´ÊàëÁ¢∫Ë™ç‰∏ã ÊàëÁõÆÂâçÁöÑÁßªÊ§çÂÅöÂÆå‰∫ÜÂóé" (Help me check if my current port is done)
   - "Âπ´ÊàëÊääÁõÆÂâçÂÆåÊàêÁöÑÁãÄÊÖãÊõ¥Êñ∞Âà∞plan‰∏ä" (Help me update the completed status to the plan)
   - `/compound-engineering:workflows:work` on Phase 2 remaining tasks (cellular warning, multi-device test)
   - `/compound-engineering:workflows:work docs/plans/2026-02-12-feat-ios-react-native-port-plan.md "Implement Phase 5: Settings, onboarding, theme, error handling, accessibility" Âπ´ÊàëÊääÈÇÑÊ≤íÂÅöÂÆåÁöÑÈÉ®ÂàÜÂÆåÊàê`
   - "commit"

7. Pending Tasks:
   - **Commit remaining unstaged changes**: The user said "commit" and I was examining what to commit. The unstaged changes include ~200 deleted desktop Electron files (moved to `reference/` in a prior session), the untracked `reference/` directory (1.3GB), `docs/plans/2026-02-12-research-ios-keyboard-extension.md` (untracked), `.claude/settings.json` (modified), and `modules/whisperkit/WhisperKit.podspec` (deleted, renamed earlier).

8. Current Work:
   The user said "commit" and I ran `git status -s`, `git diff --stat`, and `git log --oneline -5` to assess what needs to be committed. The findings:
   - ~200 deleted files (old desktop Electron code)
   - `reference/` directory (1.3GB, untracked) ‚Äî the desktop project copy
   - `docs/plans/2026-02-12-research-ios-keyboard-extension.md` (untracked research doc)
   - `.claude/settings.json` (modified)
   - `modules/whisperkit/WhisperKit.podspec` (deleted ‚Äî renamed to WhisperKitModule.podspec in prior session)
   
   I checked `reference/` size (1.3GB) and that `.gitignore` has `reference/node_modules/` but not `reference/` itself. I was about to decide what to stage and commit when the summary was requested.

   Commits already made on `mobile` branch this session:
   ```
   40e7fed docs: mark Phase 5 complete in plan, update progress summary
   7c5a0ec feat(eas): add EAS Build configuration for TestFlight distribution
   5d2d233 feat(config): add dark mode splash screen and iOS build number
   51aad5d feat(a11y): add VoiceOver accessibility across all screens
   f84ad1b feat(polish): add audio cues, edge case handling, and error resilience
   550d4c5 feat(whisperkit): add cellular download warning and device compatibility checks
   ```

9. Optional Next Step:
   Complete the user's "commit" request. The user explicitly said "commit" and I need to stage and commit the remaining unstaged changes. The main decision is whether to:
   - Commit the desktop file deletions + `reference/` directory together as a cleanup commit
   - Or ask the user if they want `reference/` tracked in git (it's 1.3GB which is large for a git repo)
   
   Given the `reference/` directory is 1.3GB and contains `node_modules` (excluded by gitignore), this likely should be committed but warrants confirming the size implications. The file deletions and `reference/` addition are logically one operation ("move desktop code to reference directory").

If you need specific details from before compaction (like exact code snippets, error messages, or content you generated), read the full transcript at: /Users/weirenlan/.REDACTED.jsonl
Please continue the conversation from where we left off without asking the user any further questions. Continue with the last task that you were asked to work on.